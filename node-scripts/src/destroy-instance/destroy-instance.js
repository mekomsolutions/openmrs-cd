"use strict";

/**
 * Main script of the 'host preparation' stage.
 *
 */

const fs = require("fs");
const path = require("path");
const _ = require("lodash");

const utils = require("../utils/utils");
const model = require("../utils/model");
const cst = require("../const");
const config = require(cst.CONFIGPATH);
const db = require(cst.DBPATH);

const scripts = require("../pipeline3/scripts");
const currentStage = config.getHostPrepareStatusCode();

var downstreamJobParams = {};

downstreamJobParams[config.varDownstreamJob()] = "";

//
//  Fetching the instance definition based on the provided UUID
//
var instanceDef = db.getInstanceDefinition(
  process.env[config.varInstanceUuid()]
);
if (_.isEmpty(instanceDef)) {
  throw new Error("Illegal argument: empty or unexisting instance definition.");
}

//
//  Host metadata
//
var ssh = instanceDef.deployment.host.value; // TODO this should be extracted based on the host type
var hostDir = (hostDir = path.resolve(
  instanceDef.deployment.hostDir,
  instanceDef.name
));
const deploymentScripts = require("../pipeline3/impl/" +
  instanceDef.deployment.type);

//
//  Building the script
//
var script = new model.Script();
script.type = "#!/bin/bash";
script.headComment = "# Autogenerated script for the CD instance reset...";
script.body = [];
script.body.push("set -xe\n");

script.body.push(
  scripts.remote(ssh, deploymentScripts.stop(instanceDef, true))
);

script.body.push(
  scripts.remote(ssh, deploymentScripts.remove(instanceDef, true))
);

script.body = script.body.join(cst.SCRIPT_SEPARATOR);

if (process.env[config.getVarRecreate()] == "true") {
  // Setting downstream job to Pipeline3
  downstreamJobParams[
    config.varDownstreamJob()
  ] = config.getJobNameForPipeline3();

  downstreamJobParams[config.varInstanceUuid()] = instanceDef.uuid;
  var displayName = instanceDef.name ? instanceDef.name : "no-name-set";
  downstreamJobParams[config.varInstanceName()] = displayName;
  downstreamJobParams[config.varArtifactsChanges()] = JSON.stringify(
    !_.isEmpty(instanceDef.artifacts)
  );
  downstreamJobParams[config.varDeploymentChanges()] = JSON.stringify(
    !_.isEmpty(instanceDef.deployment)
  );
  downstreamJobParams[config.varDataChanges()] = JSON.stringify(
    !_.isEmpty(instanceDef.data)
  );
  downstreamJobParams[config.varPropertiesChanges()] = JSON.stringify(
    !_.isEmpty(instanceDef.properties)
  );
  downstreamJobParams[config.varCreation()] = JSON.stringify(false);
}

//
//  Saving the script in the current build dir.
//
fs.writeFileSync(
  path.resolve(config.getBuildDirPath(), config.getResetInstanceScriptName()),
  utils.getScriptAsString(script)
);
fs.chmodSync(
  path.resolve(config.getBuildDirPath(), config.getResetInstanceScriptName()),
  "0755"
);

// Set the build name
var buildName = [];
buildName[config.varBuildName()] = instanceDef.name + " - " + instanceDef.uuid;
downstreamJobParams["instanceActive"] = JSON.stringify(
  _.isEmpty(instanceDef.active) ? true : instanceDef.active
);

//
// Export the downstream job parameters as a 'environment' properties file
//
fs.writeFileSync(
  config.getProjectBuildEnvvarsPath(),
  utils.convertToProperties(Object.assign(buildName, downstreamJobParams))
);

// Saving the status
fs.writeFileSync(
  path.resolve(config.getBuildDirPath(), config.getStatusFileName()),
  JSON.stringify({ status: currentStage })
);
